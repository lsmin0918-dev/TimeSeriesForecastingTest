import json
import os

# Solution Codes
CODE_MODEL = [
    "# MyTradingModel: RobustGRU êµ¬í˜„ (Improved over ExampleLSTM)\n",
    "class MyTradingModel(nn.Module):\n",
    "    \"\"\"\n",
    "    RobustGRU: 2-layer GRU with Dropout & BatchNorm\n",
    "    \"\"\"\n",
    "    def __init__(self, input_size, hidden_size=128, dropout=0.3):\n",
    "        super(MyTradingModel, self).__init__()\n",
    "        \n",
    "        # ì²« ë²ˆì§¸ GRU ë ˆì´ì–´\n",
    "        self.gru1 = nn.GRU(input_size, hidden_size, batch_first=True, num_layers=1, bidirectional=False)\n",
    "        self.dropout1 = nn.Dropout(dropout)\n",
    "        self.bn1 = nn.BatchNorm1d(hidden_size)\n",
    "        \n",
    "        # ë‘ ë²ˆì§¸ GRU ë ˆì´ì–´ (í¬ê¸° ì¶•ì†Œ)\n",
    "        self.gru2 = nn.GRU(hidden_size, hidden_size//2, batch_first=True, num_layers=1)\n",
    "        self.dropout2 = nn.Dropout(dropout)\n",
    "        self.bn2 = nn.BatchNorm1d(hidden_size//2)\n",
    "        \n",
    "        # ì™„ì „ ì—°ê²°ì¸µ (FC)\n",
    "        self.fc1 = nn.Linear(hidden_size//2, 32)\n",
    "        self.relu = nn.ReLU()\n",
    "        self.dropout3 = nn.Dropout(dropout)\n",
    "        \n",
    "        self.fc2 = nn.Linear(32, 1)\n",
    "        self.sigmoid = nn.Sigmoid()\n",
    "        \n",
    "    def forward(self, x):\n",
    "        # x shape: (batch, seq, feature)\n",
    "        out, _ = self.gru1(x)\n",
    "        out = self.dropout1(out)\n",
    "        \n",
    "        # BatchNormì„ ìœ„í•œ ì°¨ì› ë³€ê²½ (batch, hidden, seq)\n",
    "        out = out.permute(0, 2, 1)\n",
    "        out = self.bn1(out)\n",
    "        out = out.permute(0, 2, 1)\n",
    "        \n",
    "        out, _ = self.gru2(out)\n",
    "        \n",
    "        # ë§ˆì§€ë§‰ íƒ€ì„ìŠ¤í…ë§Œ ì‚¬ìš©\n",
    "        out = out[:, -1, :] \n",
    "        \n",
    "        out = self.dropout2(out)\n",
    "        out = self.bn2(out)\n",
    "        \n",
    "        out = self.fc1(out)\n",
    "        out = self.relu(out)\n",
    "        out = self.dropout3(out)\n",
    "        \n",
    "        out = self.fc2(out)\n",
    "        out = self.sigmoid(out)\n",
    "        return out\n",
    "\n",
    "# ëª¨ë¸ ìƒì„± (GPU ì‚¬ìš©)\n",
    "my_model = MyTradingModel(\n",
    "    input_size=X_train_seq.shape[2],\n",
    "    hidden_size=128,\n",
    "    dropout=0.3\n",
    ").to(device)\n",
    "\n",
    "print(\"âœ… ë‚˜ì˜ ëª¨ë¸(RobustGRU) ìƒì„± ì™„ë£Œ!\")\n",
    "print(my_model)\n",
    "print(f\"\\nTotal parameters: {sum(p.numel() for p in my_model.parameters()):,}\")"
]

CODE_TRAIN = [
    "# ì»¤ìŠ¤í…€ í•™ìŠµ í•¨ìˆ˜ (Weight Decay ì ìš©í•˜ì—¬ ê³¼ì í•© ë°©ì§€)\n",
    "def train_model_custom(model, train_loader, val_loader, epochs=100, lr=0.001, patience=15):\n",
    "    model = model.to(device)\n",
    "    criterion = nn.BCELoss()\n",
    "    # L2 ê·œì œ(Weight Decay) ì¶”ê°€\n",
    "    optimizer = torch.optim.Adam(model.parameters(), lr=lr, weight_decay=1e-5) \n",
    "    \n",
    "    history = {'train_loss': [], 'val_loss': [], 'train_acc': [], 'val_acc': []}\n",
    "    best_val_loss = float('inf')\n",
    "    patience_counter = 0\n",
    "    best_model_state = None\n",
    "    \n",
    "    for epoch in range(epochs):\n",
    "        model.train()\n",
    "        train_loss = 0\n",
    "        train_correct = 0\n",
    "        train_total = 0\n",
    "        \n",
    "        for batch_X, batch_y in train_loader:\n",
    "            batch_X, batch_y = batch_X.to(device), batch_y.to(device)\n",
    "            optimizer.zero_grad()\n",
    "            outputs = model(batch_X)\n",
    "            loss = criterion(outputs, batch_y.unsqueeze(1))\n",
    "            loss.backward()\n",
    "            optimizer.step()\n",
    "            \n",
    "            train_loss += loss.item()\n",
    "            predicted = (outputs > 0.5).float()\n",
    "            train_total += batch_y.size(0)\n",
    "            train_correct += (predicted.squeeze() == batch_y).sum().item()\n",
    "            \n",
    "        avg_train_loss = train_loss / len(train_loader)\n",
    "        train_acc = train_correct / train_total\n",
    "        \n",
    "        model.eval()\n",
    "        val_loss = 0\n",
    "        val_correct = 0\n",
    "        val_total = 0\n",
    "        \n",
    "        with torch.no_grad():\n",
    "            for batch_X, batch_y in val_loader:\n",
    "                batch_X, batch_y = batch_X.to(device), batch_y.to(device)\n",
    "                outputs = model(batch_X)\n",
    "                loss = criterion(outputs, batch_y.unsqueeze(1))\n",
    "                val_loss += loss.item()\n",
    "                \n",
    "                predicted = (outputs > 0.5).float()\n",
    "                val_total += batch_y.size(0)\n",
    "                val_correct += (predicted.squeeze() == batch_y).sum().item()\n",
    "        \n",
    "        avg_val_loss = val_loss / len(val_loader)\n",
    "        val_acc = val_correct / val_total\n",
    "        \n",
    "        history['train_loss'].append(avg_train_loss)\n",
    "        history['val_loss'].append(avg_val_loss)\n",
    "        history['train_acc'].append(train_acc)\n",
    "        history['val_acc'].append(val_acc)\n",
    "\n",
    "        if (epoch + 1) % 10 == 0:\n",
    "            print(f'Epoch [{epoch+1}/{epochs}], Train Loss: {avg_train_loss:.4f}, Val Loss: {avg_val_loss:.4f}')\n",
    "            \n",
    "        if avg_val_loss < best_val_loss:\n",
    "            best_val_loss = avg_val_loss\n",
    "            patience_counter = 0\n",
    "            best_model_state = model.state_dict().copy()\n",
    "        else:\n",
    "            patience_counter += 1\n",
    "            \n",
    "        if patience_counter >= patience:\n",
    "            print(f'Early stopping at epoch {epoch+1}')\n",
    "            break\n",
    "            \n",
    "    if best_model_state is not None:\n",
    "        model.load_state_dict(best_model_state)\n",
    "    return history\n",
    "\n",
    "print(\"ë‚˜ì˜ ëª¨ë¸ í•™ìŠµ ì‹œì‘...\")\n",
    "my_history = train_model_custom(\n",
    "    model=my_model,\n",
    "    train_loader=train_loader,\n",
    "    val_loader=val_loader,\n",
    "    epochs=100,\n",
    "    lr=0.0005,\n",
    "    patience=20\n",
    ")\n",
    "print(\"\\nâœ… ëª¨ë¸ í•™ìŠµ ì™„ë£Œ!\")"
]

CODE_VIS = [
    "fig, axes = plt.subplots(1, 2, figsize=(15, 5))\n",
    "\n",
    "axes[0].plot(my_history['train_loss'], label='Train Loss', linewidth=2)\n",
    "axes[0].plot(my_history['val_loss'], label='Validation Loss', linewidth=2)\n",
    "axes[0].set_title('My Model (RobustGRU) Loss', fontsize=14, fontweight='bold')\n",
    "axes[0].set_xlabel('Epoch')\n",
    "axes[0].set_ylabel('Loss')\n",
    "axes[0].legend()\n",
    "axes[0].grid(True, alpha=0.3)\n",
    "\n",
    "axes[1].plot(my_history['train_acc'], label='Train Accuracy', linewidth=2)\n",
    "axes[1].plot(my_history['val_acc'], label='Validation Accuracy', linewidth=2)\n",
    "axes[1].set_title('My Model (RobustGRU) Accuracy', fontsize=14, fontweight='bold')\n",
    "axes[1].set_xlabel('Epoch')\n",
    "axes[1].set_ylabel('Accuracy')\n",
    "axes[1].legend()\n",
    "axes[1].grid(True, alpha=0.3)\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
]

CODE_SIM = [
    "# ì˜ˆì¸¡ í•¨ìˆ˜\n",
    "def predict_with_prob(model, loader):\n",
    "    model.eval()\n",
    "    probs = []\n",
    "    with torch.no_grad():\n",
    "        for batch_X, _ in loader:\n",
    "            batch_X = batch_X.to(device)\n",
    "            out = model(batch_X)\n",
    "            probs.append(out.cpu().numpy())\n",
    "    return np.vstack(probs).flatten()\n",
    "\n",
    "# í…ŒìŠ¤íŠ¸ ì…‹ ì˜ˆì¸¡ ìˆ˜í–‰\n",
    "my_prob = predict_with_prob(my_model, test_loader)\n",
    "\n",
    "# ì‹œë®¬ë ˆì´ì…˜ìš© ë°ì´í„° ì¤€ë¹„\n",
    "test_start_idx = len(btc_features) - len(y_test) + sequence_length\n",
    "test_prices = btc_features['Close'].iloc[test_start_idx:test_start_idx+len(my_prob)].values\n",
    "test_dates = btc_features.index[test_start_idx:test_start_idx+len(my_prob)]\n",
    "\n",
    "# ë³€ë™ì„± ë°ì´í„° (ë¦¬ìŠ¤í¬ ê´€ë¦¬ìš©)\n",
    "test_volatility = btc_features['Volatility_10'].iloc[test_start_idx:test_start_idx+len(my_prob)].values\n",
    "volatility_threshold = np.percentile(test_volatility, 80)\n",
    "\n",
    "# ê³ ê¸‰ íŠ¸ë ˆì´ë”© ì „ëµ ì‹œë®¬ë ˆì´ì…˜ í•¨ìˆ˜\n",
    "def simulate_custom_strategy(probs, prices, dates, volatilities, vol_thresh, initial_capital=10000):\n",
    "    cash = initial_capital\n",
    "    btc = 0\n",
    "    tx_fee = 0.001\n",
    "    history = []\n",
    "    trade_log = []\n",
    "    \n",
    "    BUY_THRESH = 0.65\n",
    "    SELL_THRESH = 0.35\n",
    "    \n",
    "    for i in range(len(probs)):\n",
    "        prob = probs[i]\n",
    "        price = prices[i]\n",
    "        vol = volatilities[i]\n",
    "        \n",
    "        portfolio_val = cash + btc * price\n",
    "        \n",
    "        # ë§ˆì§€ë§‰ ë‚  ì „ëŸ‰ ë§¤ë„\n",
    "        if i == len(probs) - 1:\n",
    "            if btc > 0:\n",
    "                cash += btc * price * (1 - tx_fee)\n",
    "                btc = 0\n",
    "            history.append(cash)\n",
    "            continue\n",
    "            \n",
    "        # ëª©í‘œ ë¹„ì¤‘ ê³„ì‚° (í™•ë¥  ë¹„ë¡€ & ë³€ë™ì„± ë°˜ì˜)\n",
    "        if prob > BUY_THRESH:\n",
    "            raw_ratio = (prob - 0.5) * 2.0\n",
    "            target_ratio = min(max(raw_ratio, 0.0), 1.0)\n",
    "            if vol > vol_thresh:\n",
    "                target_ratio *= 0.5 \n",
    "        elif prob < SELL_THRESH:\n",
    "            target_ratio = 0.0\n",
    "        else:\n",
    "            current_value_ratio = (btc * price) / portfolio_val if portfolio_val > 0 else 0\n",
    "            target_ratio = current_value_ratio \n",
    "            \n",
    "        # ë¦¬ë°¸ëŸ°ì‹± ì‹¤í–‰\n",
    "        target_btc_val = portfolio_val * target_ratio\n",
    "        current_btc_val = btc * price\n",
    "        diff = target_btc_val - current_btc_val\n",
    "        \n",
    "        if abs(diff) < 50: # ìµœì†Œ ê±°ë˜ ê¸ˆì•¡ ì œí•œ\n",
    "            history.append(portfolio_val)\n",
    "            continue\n",
    "            \n",
    "        if diff > 0:\n",
    "            amount_to_buy_usd = diff\n",
    "            if amount_to_buy_usd > cash: amount_to_buy_usd = cash\n",
    "            btc_bought = (amount_to_buy_usd * (1 - tx_fee)) / price\n",
    "            btc += btc_bought\n",
    "            cash -= amount_to_buy_usd\n",
    "            trade_log.append({'date': dates[i], 'action': 'BUY', 'price': price, 'value': amount_to_buy_usd})\n",
    "        elif diff < 0:\n",
    "            amount_to_sell_usd = -diff\n",
    "            amount_to_sell_btc = amount_to_sell_usd / price\n",
    "            if amount_to_sell_btc > btc: amount_to_sell_btc = btc\n",
    "            cash_gained = amount_to_sell_btc * price * (1 - tx_fee)\n",
    "            cash += cash_gained\n",
    "            btc -= amount_to_sell_btc\n",
    "            trade_log.append({'date': dates[i], 'action': 'SELL', 'price': price, 'value': cash_gained})\n",
    "            \n",
    "        history.append(cash + btc * price)\n",
    "\n",
    "    total_return = (history[-1] - initial_capital) / initial_capital * 100\n",
    "    \n",
    "    return {\n",
    "        'initial_capital': initial_capital,\n",
    "        'final_value': history[-1],\n",
    "        'total_return': total_return,\n",
    "        'portfolio_values': history,\n",
    "        'num_trades': len(trade_log),\n",
    "        'total_fees_paid': 0 # Simplified\n",
    "    }\n",
    "\n",
    "# ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰\n",
    "my_result = simulate_custom_strategy(\n",
    "    probs=my_prob,\n",
    "    prices=test_prices,\n",
    "    dates=test_dates,\n",
    "    volatilities=test_volatility,\n",
    "    vol_thresh=volatility_threshold\n",
    ")\n",
    "\n",
    "print(\"=\"*70)\n",
    "print(\"ğŸš€ ë‚˜ì˜ íŠ¸ë ˆì´ë”© ì „ëµ ê²°ê³¼ (Advanced Strategy)\")\n",
    "print(\"=\"*70)\n",
    "print(f\"ì´ˆê¸° ìë³¸: ${my_result['initial_capital']:,.2f}\")\n",
    "print(f\"ìµœì¢… ìë³¸: ${my_result['final_value']:,.2f}\")\n",
    "print(f\"ìˆ˜ìµë¥ : {my_result['total_return']:.2f}%\")\n",
    "print(f\"ê±°ë˜ íšŸìˆ˜: {my_result['num_trades']}íšŒ\")\n",
    "print(\"=\"*70)"
]

CODE_RESULT = [
    "fig, axes = plt.subplots(2, 1, figsize=(15, 10))\n",
    "\n",
    "# í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ë³€í™” ë¹„êµ\n",
    "axes[0].plot(test_dates, buy_hold_portfolio, \n",
    "            label=f\"Buy and Hold ({buy_hold_return:.2f}%)\", \n",
    "            linewidth=2.5, linestyle=\"--\", color=\"black\", alpha=0.7)\n",
    "axes[0].plot(test_dates, example_result_prob[\"portfolio_values\"], \n",
    "            label=f\"Example Model ({example_result_prob['total_return']:.2f}%)\", \n",
    "            linewidth=2, color=\"blue\", alpha=0.5)\n",
    "axes[0].plot(test_dates, my_result[\"portfolio_values\"], \n",
    "            label=f\"My Model ({my_result['total_return']:.2f}%)\", \n",
    "            linewidth=2, color=\"red\")\n",
    "axes[0].axhline(y=10000, color=\"gray\", linestyle=\":\", linewidth=1, label=\"Initial Capital\")\n",
    "axes[0].set_title(\"Portfolio Value Over Time\", fontsize=14, fontweight=\"bold\")\n",
    "axes[0].set_ylabel(\"Portfolio Value ($)\")\n",
    "axes[0].legend()\n",
    "axes[0].grid(True, alpha=0.3)\n",
    "\n",
    "# ìˆ˜ìµë¥  ë§‰ëŒ€ ê·¸ë˜í”„ ë¹„êµ\n",
    "strategies = [\"Buy and Hold\", \"Example Model\", \"My Model\"]\n",
    "returns = [buy_hold_return, example_result_prob['total_return'], my_result['total_return']]\n",
    "colors = ['green' if r > 0 else 'red' for r in returns]\n",
    "\n",
    "axes[1].bar(strategies, returns, color=colors, alpha=0.7)\n",
    "axes[1].axhline(y=0, color=\"black\", linestyle=\"-\", linewidth=1)\n",
    "axes[1].set_title(\"Total Return Comparison\", fontsize=14, fontweight=\"bold\")\n",
    "axes[1].set_ylabel(\"Return (%)\")\n",
    "axes[1].grid(axis=\"y\", alpha=0.3)\n",
    "\n",
    "for i, (strategy, ret) in enumerate(zip(strategies, returns)):\n",
    "    axes[1].text(i, ret, f'{ret:.2f}%', ha='center', \n",
    "                va='bottom' if ret > 0 else 'top', fontweight='bold')\n",
    "\n",
    "plt.tight_layout()\n",
    "plt.show()"
]

nb_path = "c:\\AI\\FinalProject\\TimeSeriesForecastingTest\\assignment_notebook.ipynb"

with open(nb_path, "r", encoding="utf-8") as f:
    nb = json.load(f)

# Find relevant cells and replace
modified_count = 0
for cell in nb["cells"]:
    if cell["cell_type"] != "code":
        continue
    
    source_str = "".join(cell["source"])
    
    if "# TODO: ìì‹ ë§Œì˜ ëª¨ë¸ êµ¬í˜„" in source_str:
        print("Found Model Implementation Cell")
        cell["source"] = CODE_MODEL
        modified_count += 1
        
    elif "# TODO: ëª¨ë¸ í•™ìŠµ (ì£¼ì„ í•´ì œ í›„ ì‚¬ìš©)" in source_str:
        print("Found Model Training Cell")
        cell["source"] = CODE_TRAIN
        modified_count += 1
        
    elif "# TODO: í•™ìŠµ ê³¼ì • ì‹œê°í™” (ì„ íƒì‚¬í•­)" in source_str:
        print("Found Visualization Cell")
        cell["source"] = CODE_VIS
        modified_count += 1
        
    elif "# TODO: ì˜ˆì¸¡ ë° íŠ¸ë ˆì´ë”© ì‹œë®¬ë ˆì´ì…˜ (ì£¼ì„ í•´ì œ í›„ ì‚¬ìš©)" in source_str:
        print("Found Simulation Cell")
        cell["source"] = CODE_SIM
        modified_count += 1
        
    elif "# TODO: ìµœì¢… ê²°ê³¼ ë¹„êµ (ì£¼ì„ í•´ì œ í›„ ì‚¬ìš©)" in source_str:
        print("Found Result Comparison Cell")
        cell["source"] = CODE_RESULT
        modified_count += 1

if modified_count == 5:
    print("All targeted cells updated.")
    with open(nb_path, "w", encoding="utf-8") as f:
        json.dump(nb, f, indent=1, ensure_ascii=False)
    print("Notebook saved successfully.")
else:
    print(f"Warning: Only {modified_count}/5 cells matched.")
